<!DOCTYPE html>
<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.52.0/dist/phaser-arcade-physics.min.js"></script>
</head>

<body>

  <script>
    var config = {
      type: Phaser.AUTO,
      width: 1280,
      height: 720,
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { x: 0, y: 0 },
          debug: false,
        }
      },
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };

    var game = new Phaser.Game(config);

    function preload() {
      this.load.setBaseURL('../assets');
      this.load.image('cell', 'cell.png');
      this.load.image('softbg', 'softbg.jpg');
      this.load.image('sugar', 'molecule.png');
      this.load.image('arrow', 'arrow.png');
      this.load.image('particles/blue', 'particles/blue.png');

      this.load.audio('click', 'sounds/click.wav');
      this.load.audio('powerup', 'sounds/powerup.wav');
      this.load.audio('bgmusic', 'music/ftl-title-theme.mp3');
    }

    class Entity {
      constructor(gameObject) {
        this.gameObject = gameObject;
        gameObject.entity = this;
      }

      onClick() {
        console.log('hi');
      }

      onPointerIn() {
        if (!this.gameObject) return;
        this.gameObject.setTint(0x88ff88);
      }

      onPointerOut() {
        if (!this.gameObject) return;
        this.gameObject.clearTint();
      }
    }

    class SugarEntity extends Entity {
      constructor(go) {
        super(go);
      }

      update(dt) {
        if (!this.gameObject) return;
      }

      destroy() {
        this.gameObject.destroy();
        this.gameObject = null;
      }

      onClick() {
        if (selectedCellEntity) {
          selectedCellEntity.targetMode = 'ent';
          selectedCellEntity.targetEnt = this;
        }
      }

    }

    const MAX_CELL_SPEED = 300;

    // Gross
    let imageWasJustClicked = false;

    let explosionEmitter = null;
    let clickEmitter = null;

    let pointerObject = null;
    let selectedCellEntity = null;

    class CellEntity extends Entity {
      constructor(go) {
        super(go);
        this.targetMode = 'none';

        this.prevVelX = 0;
        this.prevVelY = 0;
      }

      goTowards(x, y, dt) {
        let dx = x - this.gameObject.x;
        let dy = y - this.gameObject.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= 0) return;

        let easiness = 20;
        let speed = MAX_CELL_SPEED * (1 - 1 / (dist / easiness + 1));
        this.prevVelX = dx / dist * speed;
        this.prevVelY = dy / dist * speed;
        this.gameObject.setVelocity(this.prevVelX, this.prevVelY);
      }

      update(dtMs) {
        if (!this.gameObject) return;

        if (this.targetMode == 'pos') {
          this.goTowards(this.targetX, this.targetY, dtMs);
        }
        else if (this.targetMode == 'ent') {
          if (this.targetEnt == null || this.targetEnt.gameObject == null) {
            // It's gone - just go a bit past it
            this.targetMode = 'pos';
            let pastTime = 0.1;
            this.targetX = this.gameObject.x + this.prevVelX * pastTime;
            this.targetY = this.gameObject.y + this.prevVelY * pastTime;
          } else {
            this.goTowards(this.targetEnt.gameObject.x, this.targetEnt.gameObject.y, dtMs);
          }
        }

        this.gameObject.angle += dtMs / 1000 * 180;
      }
    }

    function create() {
      this.sound.add('bgmusic', { loop: true, volume: 0.2 }).play();

      this.clickAudio = this.sound.add('click', { volume: 0.1 });
      this.powerupAudio = this.sound.add('powerup', { volume: 0.1 });

      this.add.image(config.width / 2, config.height / 2, 'softbg').depth = 0;

      this.entities = [];

      var cellImage = this.physics.add.image(config.width / 2, config.height / 2, 'cell');
      cellImage.setCircle(32);
      cellImage.setVelocity(1, 1);
      cellImage.setBounce(1, 1);
      cellImage.setCollideWorldBounds(true);

      let cell = new CellEntity(cellImage);
      selectedCellEntity = cell;
      this.entities.push(cell)

      for (let i = 0; i < 5; i++) {
        var sugarImage = this.physics.add.image(Math.random() * config.width, Math.random() * config.height, 'sugar');
        sugarImage.setCircle(32);
        sugarImage.setVelocity((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
        sugarImage.setAngularVelocity((Math.random() - 0.5) * 180);
        sugarImage.setBounce(1, 1);
        sugarImage.setCollideWorldBounds(true);
        let sugar = new SugarEntity(sugarImage);
        this.entities.push(sugar);

        this.physics.add.overlap(sugarImage, cellImage, (sugarImage, cellImage) => {
          explosionEmitter.explode(100, sugarImage.x, sugarImage.y);
          sugar.destroy();
          this.powerupAudio.play();
        });
      }

      var particles = this.add.particles('particles/blue');
      particles.depth = 1;
      var emitter = particles.createEmitter({
        speed: 500,
        lifespan: 1000,
        scale: { start: 1, end: 0 },
        blendMode: 'ADD'
      });
      emitter.stop();

      explosionEmitter = emitter;

      clickEmitter = particles.createEmitter({
        speed: 200,
        lifespan: 250,
        scale: { start: 1, end: 0 },
        blendMode: 'ADD'
      });
      clickEmitter.stop();

      pointerObject = this.add.image(100, 100, 'arrow').setOrigin(0, 0);
      game.canvas.addEventListener('mousedown', () => {
        this.input.mouse.requestPointerLock();
      });

      let getObjectsUnderPointer = () => {
        return this.physics.overlapRect(pointerObject.x, pointerObject.y, 1, 1);
      };

      let prevHoveredEnts = new Set();

      this.input.on('pointermove', (pointer) => {
        if (!this.input.mouse.locked) {
          return;
        }
        let sprite = pointerObject;
        sprite.x += pointer.movementX;
        sprite.y += pointer.movementY;
        sprite.x = Phaser.Math.Clamp(sprite.x, 0, game.renderer.width - 8);
        sprite.y = Phaser.Math.Clamp(sprite.y, 0, game.renderer.height - 8);

        let hoveredEnts = new Set();
        for (let body of getObjectsUnderPointer()) {
          if (body.gameObject.entity) {
            hoveredEnts.add(body.gameObject.entity);
          }
        }

        for (let ent of hoveredEnts) {
          if (!prevHoveredEnts.has(ent)) {
            ent.onPointerIn();
          }
        }

        for (let ent of prevHoveredEnts) {
          if (!hoveredEnts.has(ent)) {
            ent.onPointerOut();
          }
        }

        prevHoveredEnts = hoveredEnts;
      });

      // Scene-wide click handler
      this.input.on('pointerdown', (pointer) => {
        if (!this.input.mouse.locked) {
          pointerObject.x = pointer.x;
          pointerObject.y = pointer.y;
          return;
        }

        clickEmitter.explode(30, pointerObject.x, pointerObject.y);
        this.clickAudio.play();

        let clickedAny = false;
        for (let body of getObjectsUnderPointer()) {
          if (body.gameObject.entity) {
            body.gameObject.entity.onClick();
            clickedAny = true;
          }
        }

        if (!clickedAny) {
          // Clicked bg
          cell.targetMode = 'pos';
          cell.targetX = pointerObject.x;
          cell.targetY = pointerObject.y;
        }
      });

      this.pointerLockText = this.add.text(
        0, 0,
        'Click to play',
        { font: "48px Arial Black", fill: "#000", align: 'center' });
      this.pointerLockText.setStroke('#fff', 8);
      this.pointerLockText.x = config.width / 2 - this.pointerLockText.width / 2;
      this.pointerLockText.y = config.height * 0.3 - this.pointerLockText.height / 2;
    }

    function update(time, deltaTime) {
      for (let ent of this.entities) {
        ent.update(deltaTime);
      }

      this.pointerLockText.setVisible(!this.input.mouse.locked);
    }
  </script>

</body>

</html>